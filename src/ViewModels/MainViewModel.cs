using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Microsoft.Win32;
using PdfMerger.Helpers;
using PdfMerger.Models;
using PdfMerger.Services;

namespace PdfMerger.ViewModels
{
  public class MainViewModel : ViewModelBase
  {
    private readonly PdfService _pdfService;
    private readonly Logger _logger;
    private readonly FileHelper _fileHelper;
    private bool _isMerging;
    private int _mergeProgress;
    private bool _autoOpenAfterMerge = true;
    private bool _useAutoGeneratedFilename = false;
    private string? _lastSaveLocation;
    private string _statusMessage = "Ready";

    public ObservableCollection<PdfFile> PdfFiles { get; } = new ObservableCollection<PdfFile>();

    public ICommand AddFilesCommand { get; }
    public ICommand RemoveFileCommand { get; }
    public ICommand ClearFilesCommand { get; }
    public ICommand MoveUpCommand { get; }
    public ICommand MoveDownCommand { get; }
    public ICommand MergePdfsCommand { get; }

    public bool IsMerging
    {
      get => _isMerging;
      set => SetProperty(ref _isMerging, value);
    }

    public int MergeProgress
    {
      get => _mergeProgress;
      set => SetProperty(ref _mergeProgress, value);
    }

    public bool AutoOpenAfterMerge
    {
      get => _autoOpenAfterMerge;
      set => SetProperty(ref _autoOpenAfterMerge, value);
    }

    public bool UseAutoGeneratedFilename
    {
      get => _useAutoGeneratedFilename;
      set => SetProperty(ref _useAutoGeneratedFilename, value);
    }

    public string? LastSaveLocation
    {
      get => _lastSaveLocation;
      private set => SetProperty(ref _lastSaveLocation, value);
    }

    public string StatusMessage
    {
      get => _statusMessage;
      set => SetProperty(ref _statusMessage, value);
    }

    public MainViewModel(PdfService pdfService, Logger logger)
    {
      _pdfService = pdfService ?? throw new ArgumentNullException(nameof(pdfService));
      _logger = logger ?? throw new ArgumentNullException(nameof(logger));
      _fileHelper = new FileHelper(logger);

      // Initialize LastSaveLocation to Desktop
      LastSaveLocation = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

      AddFilesCommand = new RelayCommand(_ => AddFiles());
      RemoveFileCommand = new RelayCommand(RemoveFile, CanRemoveFile);
      ClearFilesCommand = new RelayCommand(_ => ClearFiles(), _ => PdfFiles.Any());
      MoveUpCommand = new RelayCommand(MoveFileUp, CanMoveFileUp);
      MoveDownCommand = new RelayCommand(MoveFileDown, CanMoveFileDown);
      MergePdfsCommand = new RelayCommand(_ => MergePdfs(), _ => CanMergePdfs());

      _logger.Log("MainViewModel initialized", LogLevel.Info);
    }

    private void AddFiles()
    {
      try
      {
        var openFileDialog = new OpenFileDialog
        {
          Filter = "PDF Files (*.pdf)|*.pdf",
          Multiselect = true,
          Title = "Select PDF Files"
        };

        if (openFileDialog.ShowDialog() == true)
        {
          foreach (string filePath in openFileDialog.FileNames)
          {
            if (FileHelper.IsPdfFile(filePath))
            {
              PdfFiles.Add(FileHelper.CreatePdfFile(filePath));
              _logger.Log($"Added file: {filePath}", LogLevel.Info);
            }
            else
            {
              _logger.Log($"Attempted to add non-PDF file: {filePath}", LogLevel.Warning);
              MessageBox.Show($"The file {Path.GetFileName(filePath)} is not a valid PDF file.",
                  "Invalid File", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
          }
        }
      }
      catch (Exception ex)
      {
        _logger.LogError("Error adding files", ex);
        MessageBox.Show($"Error adding files: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
      }
    }

    private bool CanRemoveFile(object parameter)
    {
      if (parameter is PdfFile file)
      {
        return PdfFiles.Contains(file);
      }
      return false;
    }

    private void RemoveFile(object parameter)
    {
      if (parameter is PdfFile file)
      {
        PdfFiles.Remove(file);
        _logger.Log($"Removed file: {file.FilePath}", LogLevel.Info);
      }
    }

    private void ClearFiles()
    {
      PdfFiles.Clear();
      _logger.Log("Cleared all files", LogLevel.Info);
    }

    private bool CanMoveFileUp(object parameter)
    {
      if (parameter is PdfFile file)
      {
        int index = PdfFiles.IndexOf(file);
        return index > 0;
      }
      return false;
    }

    private void MoveFileUp(object parameter)
    {
      if (parameter is PdfFile file)
      {
        int index = PdfFiles.IndexOf(file);
        if (index > 0)
        {
          PdfFiles.Move(index, index - 1);
          _logger.Log($"Moved file up: {file.FilePath}", LogLevel.Info);
        }
      }
    }

    private bool CanMoveFileDown(object parameter)
    {
      if (parameter is PdfFile file)
      {
        int index = PdfFiles.IndexOf(file);
        return index >= 0 && index < PdfFiles.Count - 1;
      }
      return false;
    }

    private void MoveFileDown(object parameter)
    {
      if (parameter is PdfFile file)
      {
        int index = PdfFiles.IndexOf(file);
        if (index >= 0 && index < PdfFiles.Count - 1)
        {
          PdfFiles.Move(index, index + 1);
          _logger.Log($"Moved file down: {file.FilePath}", LogLevel.Info);
        }
      }
    }

    private bool CanMergePdfs()
    {
      return PdfFiles.Count >= 2 && !IsMerging;
    }

    private async void MergePdfs()
    {
      if (PdfFiles.Count < 2)
      {
        MessageBox.Show("Please select at least two PDF files to merge.",
            "Not Enough Files", MessageBoxButton.OK, MessageBoxImage.Information);
        return;
      }

      try
      {
        string? outputPath = null;

        // If not using auto-generated filename, show save dialog
        if (!UseAutoGeneratedFilename)
        {
          var saveFileDialog = new SaveFileDialog
          {
            Filter = "PDF Files (*.pdf)|*.pdf",
            Title = "Save Merged PDF As",
            InitialDirectory = LastSaveLocation ?? Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
            FileName = "Merged.pdf"
          };

          if (saveFileDialog.ShowDialog() != true)
          {
            return; // User cancelled
          }

          outputPath = saveFileDialog.FileName;
          LastSaveLocation = Path.GetDirectoryName(outputPath);
        }

        IsMerging = true;
        MergeProgress = 0;

        _logger.Log($"Starting merge of {PdfFiles.Count} files", LogLevel.Info);

        var progress = new Progress<int>(value => MergeProgress = value);
        string finalPath = await _pdfService.MergePdfsAsync(PdfFiles.ToList(), outputPath, progress);

        _logger.Log($"Merge completed successfully. Output file: {finalPath}", LogLevel.Info);

        MessageBox.Show($"PDFs merged successfully!\nSaved to: {finalPath}",
            "Merge Complete", MessageBoxButton.OK, MessageBoxImage.Information);

        if (AutoOpenAfterMerge)
        {
          _fileHelper.OpenFile(finalPath);
        }
      }
      catch (Exception ex)
      {
        _logger.LogError("Error merging PDFs", ex);
        MessageBox.Show($"Error merging PDFs: {ex.Message}",
            "Merge Error", MessageBoxButton.OK, MessageBoxImage.Error);
      }
      finally
      {
        IsMerging = false;
        MergeProgress = 0;
      }
    }
  }
}